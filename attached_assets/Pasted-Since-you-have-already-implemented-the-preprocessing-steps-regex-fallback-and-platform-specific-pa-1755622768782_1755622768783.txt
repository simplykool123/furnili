Since you have already implemented the preprocessing steps, regex fallback, and platform-specific parsing, here are a few additional tips to fine-tune and ensure the reliability of your current solution:

1. Ensure OCR Accuracy Across Different Layouts

Layout Variability: As receipts across platforms (CRED, GPay, PhonePe, Paytm) have varying designs, you need to ensure that the extractor is robust enough to handle these differences. I recommend adding fallback logic that switches between different parsing strategies based on platform-specific characteristics (such as the presence of specific keywords like "Paid", "INR", "Rs." for Paytm).

Here's an example of how you can structure this for various platforms:

function extractPaymentDetails(platform, lines) {
    switch(platform) {
        case "gpay":
            return extractGPayData(lines);
        case "cred":
            return extractCredData(lines);
        case "phonepe":
            return extractPhonePeData(lines);
        case "paytm":
            return extractPaytmData(lines);
        default:
            return { recipient: "", amount: "", description: "" };
    }
}

function extractGPayData(lines) {
    // Example for GPay
    let amount = "";
    let recipient = "";
    for (let line of lines) {
        if (/₹/.test(line)) {
            amount = extractAmount(line);
        }
        if (line.includes("To")) {
            recipient = line.split("To")[1].trim();
        }
    }
    return { recipient, amount };
}


This approach ensures that your logic adapts to each platform’s specific layout, improving accuracy.

2. Enhancing Amount Extraction with Regex

Since you’ve already applied a regex fallback, try improving the regex pattern slightly to capture more variations of the amount (like amounts with commas, decimals, etc.). You can also handle cases where "₹" is split across two lines or has spaces around it.

function extractAmount(text: string): string | null {
  const regex = /(?:₹|Rs\.?|INR)?\s?(\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?)(?:\/-)?/i;
  const match = text.match(regex);
  return match ? match[1] : null;
}

3. Recipient Name Cleanup

You mentioned that the OCR sometimes returns names with trailing dots (like Kalayatan Cargo And Logistics...). Your cleanup function should ensure this is handled consistently, especially for recipient names that end with dots or unwanted characters.

Here’s an enhanced cleanup function:

function cleanRecipient(line: string): string {
  return line.replace(/\.\.\.$/, "").replace(/[^\w\s]/g, "").trim();  // Remove any non-word characters
}

4. Post-OCR Validation and Fallback

If no amount is found, your fallback strategy should be extended to check not only "paid" but also surrounding context for the amount, especially near "₹" or "Rs.".

In the case where the OCR extraction returns a lot of noise or partial results, it's helpful to add logic to search for the word "paid" or "received" as contextual anchors for amounts.

function fallbackAmount(lines: string[]): string | null {
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].toLowerCase().includes("paid") || lines[i].toLowerCase().includes("received")) {
      return extractAmount(lines[i + 1] || "");  // Check next line for amount
    }
  }
  return null;
}

5. Debugging OCR Errors

To ensure that your OCR is correctly identifying the ₹ symbol and numbers, I recommend logging the extracted text for each platform and checking which lines might be causing failures.

function logExtractedData(lines) {
  lines.forEach((line, index) => {
    console.log(`Line ${index}: ${line}`);
  });
}


This will help you visualize the lines where OCR might be missing details, allowing for more targeted adjustments.

Conclusion

Since you've already applied the core solutions (preprocessing, regex fallbacks, platform-specific logic), ensuring your system works perfectly across all platforms involves focusing on the following:

Improving platform-specific extraction logic to handle layout differences.

Enhancing regex patterns for more flexibility in amount extraction (handling commas, decimals, etc.).

Adding stronger fallback strategies for missing or incomplete data (like searching around "paid" or "received").